---
title: "告别G1拥抱ZGC？"
date: 2024-03-15T10:30:00+08:00
categories: ["JVM", "性能优化"]
tags: ["G1", "ZGC", "GC", "JVM"]
---

美团技术团队分享的《[新一代垃圾回收器ZGC的探索与实践](https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html)》

今天，我们就结合美团的宝贵经验，聊一聊从G1到ZGC的升级。

## 一、G1的瓶颈

G1的设计目标是在“吞吐量”和“延迟”之间取得平衡。它通过将堆划分为一个个Region，并优先回收垃圾最多的Region（Garbage-First）来实现可预测的停顿。

在大部分场景下，这套机制工作得很好。但G1的STW并非完全消失。它的混合GC（Mixed GC）虽然大部分标记工作是并发的，但在**对象转移**（Evacuation）阶段，依然需要STW。这个阶段需要将存活对象从一些Region（Collection Set）拷贝到另一些空的Region中。

当堆内存巨大、存活对象极多时，这个拷贝过程的耗时就会变得相当可观，STW时间会从几十毫秒攀升至数百毫秒。对于像美团风控业务那样要求65ms内返回结果，且可用性要达到99.99%的场景，G1造成的停顿显然是无法接受的。

## 二、ZGC的“黑科技”

ZGC从诞生之初，目标就极为明确：**停顿时间不应超过10ms，且不随堆大小或存活对象数量而增加。**

它是如何做到这一点的？核心在于两大“黑科技”：

1.  **着色指针（Colored Pointers）**：ZGC将对象指针的几个高位置为出来，用于存储元数据（如标记信息）。这样，GC线程在移动（重定位）对象时，应用线程通过指针就能立刻知道对象的新地址，而不需要等待一个全局的“重定位”STW阶段。

2.  **几乎完全并发**：得益于着色指针，ZGC将标记、转移、重定位这些在G1中会导致长时间STW的核心工作，都变成了与应用线程并发执行。

ZGC的GC周期中，真正的STW只有三个短暂的时刻：**初始标记、再标记、初始转移**。这三个阶段都只与GC Roots的数量有关，耗时稳定在亚毫秒级别。这正是ZGC敢于承诺“停顿时间不随堆大小增加”的底气所在。

## 三、美团的ZGC实践

理论说千遍，不如一次实践。美团的案例为我们提供了绝佳的范本。

-   **背景**：某核心服务，使用CMS（G1也测试过），Young GC平均40ms，高峰期一分钟10次，导致接口P999响应时间超标，可用性无法达标。
-   **升级**：迁移到JDK 11，启用ZGC。
-   **成果**：服务平均RT（响应时间）不变，但**P999响应时间从70ms+降低到10ms**，GC停顿的毛刺几乎完全消失，服务可用性大幅提升。


## 四、上手ZGC

从美团的经验中，我们可以提炼出一份非常实用的ZGC迁移指南。

### 1. JDK版本选择

美团在2020年实践时使用的是JDK 11。在JDK 11-14中，ZGC还是实验性功能。从**JDK 15开始，ZGC正式进入Production-Ready状态**。

**结论**：如果你想在生产环境中使用ZGC，强烈建议使用**JDK 15+** 的版本，最好是**最新的LTS版本（如JDK 17, 21）**。这些版本不仅包含了更稳定、更高效的ZGC实现，也享受更长期的官方支持。

### 2. 核心JVM参数配置

错误的参数配置是性能杀手。美团的分享和社区的最佳实践给了我们一些明确的指引：

```bash
# 1. 启用ZGC
-XX:+UseZGC

# 2. 设置堆大小，强烈建议初始值和最大值保持一致，以避免堆收缩/扩张带来的性能抖动
# ZGC可以轻松管理TB级别的堆，但请根据你的业务实际需要来设置
-Xms10g -Xmx10g

# 3. 设置并发GC线程数，这是个关键的权衡点
# - 默认值是总CPU核心数的12.5%
# - 美团经验：对于48核服务器，设置为6（48 * 0.125 = 6），在CPU占用和GC效率间取得平衡
# - 如果GC跟不上对象分配速度，可以适当调大此值，但会增加应用线程的CPU竞争
-XX:ConcGCThreads=6

# 4. 建议开启，有助于ZGC的性能
-XX:+AlwaysPreTouch

# 5. Linux环境下，开启透明大页可以提升性能
# 需要操作系统支持：echo always > /sys/kernel/mm/transparent_hugepage/enabled
-XX:+UseTransparentHugePages
```

**要避免的误区**：
-   不要手动设置 `-XX:ZCollectionInterval`，让ZGC自己决定何时触发GC。主动GC（`System.gc()`）在ZGC下通常也不是好主意。

### 3. 依赖兼容性

从JDK 8/11低版本升级到高版本JDK，不可避免地会遇到兼容性问题。美团也碰到了，但他们只花了两天就解决了。

常见的“拦路虎”包括：
-   **被移除的API**：最典型的是 `sun.misc.BASE64Encoder`，在Java 8之后就应该用 `java.util.Base64` 替代。
-   **依赖库不兼容**：一些老的第三方库可能不支持新的JDK。
    -   `Lombok`: 需要升级到较新版本。
    -   `Netty`: 需要升级到支持JDK 11+的版本。
    -   公司内部的二方、三方库，可能需要推动上游团队进行升级。

好消息是，随着JDK 17、21成为主流，大部分活跃的开源项目都已提供了良好的兼容性。

## 五、G1还是ZGC？

| 特性 | G1 | ZGC |
| :--- | :--- | :--- |
| **STW停顿** | 几十到几百毫秒，与堆大小和垃圾量相关 | **亚毫秒到几毫秒，与堆大小无关** |
| **吞吐量** | **较高**，GC对CPU的额外占用较少 | 略低于G1，因并发GC需抢占CPU资源 |
| **适用场景** | 大多数Web应用、微服务，能容忍百毫秒级停顿 | 对延迟极度敏感的场景：实时交易、直播、游戏等 |
| **JDK版本** | JDK 7+，JDK 9+默认 | **JDK 15+ 生产可用** |
| **运维成本** | 成熟，资料多，调优经验丰富 | 较新，需要拥抱新版JDK，有一定学习和迁移成本 |

**如何选择？**

1.  **问问你的SLA**：你的服务能容忍多长的停顿？如果答案是“10毫秒以上都算故障”，那么ZGC是你的不二之选。
2.  **看看你的CPU**：你的服务器CPU资源是否充足？如果CPU已经捉襟见肘，ZGC可能会让情况雪上加霜。如果CPU资源充裕，用一些吞吐量换取极致的平滑体验，是值得的。
3.  **评估你的迁移成本**：团队是否愿意升级到最新的LTS JDK版本？是否有能力处理潜在的依赖兼容性问题？

## 结语

技术没有银弹，只有取舍。G1是一位久经沙场、表现均衡的“六边形战士”，足以应对90%以上的场景。而ZGC则是一位追求极致的“剑客”，专为解决低延迟这一核心痛点而生。

在做决策前，最好的方式永远是：**在接近生产的环境下，用真实的业务流量对两者进行充分的压测和分析**。