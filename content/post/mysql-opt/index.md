
---
title: "MySQL查询优化案例：优化器为何会选错执行计划"
date: 2025-01-20T11:00:00+08:00
categories:
  - "数据库"
  - "性能优化"
tags:
  - "MySQL"
  - "SQL优化"
  - "执行计划"
description: "通过三个真实案例，深入分析MySQL查询优化器在何种情况下会选择低效的执行计划，并展示如何通过LIMIT 1、STRAIGHT_JOIN等技巧强制优化，保证查询性能的稳定。"
---

## 引言

在数据库日常维护中，我们常常会遇到一些“神奇”的慢查询：昨天还跑得飞快的SQL，今天就突然卡住了；同一个查询在主库和从库上，性能表现却有天壤之别。这些问题的根源，往往指向了MySQL的“大脑”——查询优化器（Query Optimizer）。
核心问题在于，MySQL 的查询优化器（Query Optimizer）并非在所有情况下都能选择最高效的执行计划。当统计信息不准确、数据分布特殊或查询逻辑复杂时，优化器可能会做出错误判断，导致查询性能急剧下降。以下三个案例展示了如何诊断问题并进行针对性优化。
### 案例分析


#### **案例一：利用 `LIMIT` 提前终止无效扫描**

  * **场景描述：**
    开发人员需要检查 `app` 表中特定 `bid` 和 `appid` 的记录是否存在。他们的做法是使用 `COUNT(*)` 来统计记录数，然后判断结果是否大于 0。

  * **问题分析：**
    该业务的真实意图仅仅是 **“判断存在性”**，即 “有或无”，而并非获取精确的记录总数。当表中数据量巨大时（如此处的 60865 行），`COUNT(*)` 会进行全表扫描或索引扫描以统计所有满足条件的行，造成了大量的资源浪费。

  * **低效的实现方式（推断）：**

    ```sql
    -- 原始意图的实现方式，需要扫描所有匹配的行
    SELECT COUNT(*) FROM app WHERE bid = 18171817 AND appid = 251;
    ```

  * **优化方案与 SQL：**
    通过添加 `LIMIT 1`，告知 MySQL 在找到 **第一条** 满足条件的记录后立即停止搜索并返回。这样可以将原本需要扫描 60865 行的操作，优化为只扫描 1 行。
    图片中展示了一个巧妙的 SQL 写法，通过子查询实现了这个逻辑：

    ```sql
    -- 优化后的 SQL
    SELECT count(*) FROM (
        SELECT appid FROM app
        WHERE bid = 18171817 AND appid = 251
        LIMIT 1
    ) AS tb;
    ```

    这条 SQL 的核心在于子查询中的 `LIMIT 1`，它使得 `app` 表的查询工作在找到一条记录后就结束了。外层的 `count(*)` 只是对这个临时结果（0 或 1 行）进行计数，执行成本极低。


#### **案例二：解决两表关联顺序错误**

  * **场景描述：**
    一个定时任务的 SQL 查询，过去平均执行时间为分钟级，现在突然恶化到小时级。进一步发现，同一个 SQL 在主库和从库的执行性能相差 10 倍。

  * **问题分析：**
    通过 `EXPLAIN` 分析发现，性能差异的根源在于 MySQL 优化器在主库和从库上选择了不同的 **表关联顺序**。例如，在主库上可能选择了 `a JOIN b`，而在从库上选择了 `b JOIN a`。这种不一致性通常是由于两个库之间的 **统计信息（Table Statistics）有偏差** 造成的。当统计信息不能准确反映真实的数据分布时，优化器就可能被误导，选择了一个成本更高的执行计划。

  * **有问题的 SQL：**

    ```sql
    -- 这个查询的性能在不同库上表现不一
    SELECT b.indid, a.content, a.url, a.type, a.creatda
    FROM black a, balck_ind b
    WHERE a.id = b.blackid AND a.status = 1
    ORDER BY a.id
    LIMIT 300000, 5000;
    ```

    *注意：这里的 `FROM black a, balck_ind b` 是隐式的 `INNER JOIN`，优化器有权自由决定哪张表先作为驱动表。*

  * **优化方案与原则：**
    为了避免优化器在不同环境或数据变化时“摇摆不定”，可以人工指定表的关联顺序。基本原则是：

    1.  **小表驱动大表**：用记录数较少的表（经过 `WHERE` 条件过滤后）作为驱动表。
    2.  **被驱动表的关联列必须有索引**：确保在大表上进行关联查找时，可以使用索引以提高效率。

    可以通过 `LEFT JOIN` 或者 `STRAIGHT_JOIN` 来强制指定关联顺序。例如，如果 `black` 是小表，`balck_ind` 是大表，可以改写为：

    ```sql
    -- 使用 STRAIGHT_JOIN 强制 a 作为驱动表
    SELECT b.indid, a.content, a.url, a.type, a.creatda
    FROM black a
    STRAIGHT_JOIN balck_ind b ON a.id = b.blackid
    WHERE a.status = 1
    ORDER BY a.id
    LIMIT 300000, 5000;
    ```

    `STRAIGHT_JOIN` 会强制优化器按照 SQL 中 `FROM` 子句的书写顺序（从左到右）进行关联。

-----

#### **案例三：稳定复杂多表关联的执行计划**

  * **场景描述：**
    一个涉及超过 10 张表的复杂关联查询，之前性能稳定在 1 秒左右。在新增了一张关联表后，查询性能急剧下降到数分钟。

  * **问题分析：**
    通过 `EXPLAIN` 对比优化前后的执行计划发现，问题依然出在 **表关联顺序** 上。新表的加入，或者某张表的统计信息恰好处于一个“临界点”，导致优化器重新评估后，生成了一个完全不同的、非常低效的执行计划。这种执行计划的“抖动”是复杂 SQL 在维护过程中常见的性能陷阱。

  * **优化方案与 SQL：**
    对于这种极其复杂的查询，让优化器次次都选对执行计划的风险很高。最稳妥的办法是 **人工干预**，将之前性能最好的那个执行计划的关联顺序固定下来。

    **解决方案：** 使用 `STRAIGHT_JOIN` 关键字重写整个查询，按照业务逻辑和已验证的高效顺序来排列所有的表。

    {{< figure src="image.png" alt="STRAIGHT_JOIN 示例" width="200px" >}}

    ```sql
    -- 概念性 SQL
    SELECT ...
    FROM table1 -- 驱动表
    STRAIGHT_JOIN table2 ON table1.id = table2.t1_id -- 按指定顺序关联
    STRAIGHT_JOIN table3 ON table2.id = table3.t2_id -- 继续按指定顺序关联
    ... -- 以此类推，关联所有表
    STRAIGHT_JOIN table_new ON ...
    WHERE ...;
    ```

    通过这种方式，我们等于告诉 MySQL：“不要再自己判断了，就按照我写的这个顺序去执行”。这可以消除因统计信息变化带来的性能抖动，保证查询的稳定性。

### **总结**

这组案例的核心启示是：

1.  **SQL 优化需切合业务意图**：明确查询的最终目的，避免多余的计算（如用 `LIMIT 1` 代替 `COUNT`）。
2.  **执行计划是关键**：使用 `EXPLAIN` 是排查慢查询的必备技能，它可以揭示优化器的决策过程。
3.  **不要盲信优化器**：在复杂场景下，特别是多表关联时，优化器可能会犯错。通过 `STRAIGHT_JOIN` 或调整 `JOIN` 写法来人工指定执行计划，是稳定和提升性能的终极手段之一。